* devnix

This is a set of nix functions that extend the regular nix
specifications to provide enhanced support for a development
environment.

It's relatively easy to work on a single package under nix, and
possibly even collect some dependencies, but when the number of
dependencies grows, when some of those must either be changed or newer
versions of them are needed, or when applying Hydra CI to the project,
it becomes fairly tedious to manage the nix environment.

The devnix tooling is designed to make the latter situations easier.
Simply create a ~config.nix~ that provides the high-level description
and then invoke either the ~mkRelease~ or the ~mkJobsetsDrv~ and
~mkJobset~ functions with those descriptive inputs.  These will
generate the appropriate definitions to use with ~nix-build~ or
~nix-shell~ to do local development work, and with the inclusion of a
minimal JSON declarative file, these will also generate the jobsets
needed for Hydra variants.

** Status

  The devnix tooling is currently functional.  Beta users are invited.
  Attempts will be made to keep the existing interface stable while
  adding new functionality, although they may change.

***  Pending updates

    * Better/more documentation
    * Currently support is focused on Haskell packages; support for
      other languages (e.g. Rust) should be possible in the near future.


* Usage

** With nix-shell

   Pending...

** With nix-build

   Pending...

** With hydra

   Pending...

   * Note that the devnix configurations can support the "GitTree"
     input type.  This type is not available from standard Hydra, but
     is available from https://github.com/kquick/hydra under the
     "galois" branch.  This is a single file that can be dropped into
     ~src/lib/Hydra/Plugins/~; it will recursively follow git
     submodule specifications and generate a JSON file of the
     repositories and the corresponding git submodule revision
     references for those repositories.

*** Locally recreating a hydra build

    Useful for debugging or locally working

**** Directly installing

     #+BEGIN_EXAMPLE
     $ nix-build DRV
     #+END_EXAMPLE

     where ~DRV~ is the derivation store path or output store path
     from the "Details" tab of the build.

**** Creating a shell and building as hydra

     #+BEGIN_EXAMPLE
     $ nix-shell DRV
     #+END_EXAMPLE

     Within this environment, there are shell variables that manage
     the build.  They are run as phases, although if phases isn't set,
     a default set of phases is used.  To run the full build:

     #+BEGIN_EXAMPLE
     [nix-shell] genericBuild
     #+END_EXAMPLE

     To setup the ghc-pkgs independently:

     #+BEGIN_EXAMPLE
     [nix-shell] eval "$setupCompilerEnvironmentPhase"
     #+END_EXAMPLE

     The above uses things like pkgsHostHost and pkgsHostTarget to
     configure ghc-pkgs, although the proper configuration flag needs
     to be passed to GHC to utilize that configuration:

     #+BEGIN_EXAMPLE
     [nix-shell] echo ${pkgsHostTarget[*]}
     [nix-shell] ghc-pkg --package-db="$packageConfDir" list
     #+END_EXAMPLE

     The default set of phases is:

     #+BEGIN_EXAMPLE
     phases="${prePhases:-} unpackPhase patchPhase ${preConfigurePhases:-}
             configurePhase ${preBuildPhases:-} buildPhase checkPhase
             ${preInstallPhases:-} installPhase ${preFixupPhases:-} fixupPhase installCheckPhase
             ${preDistPhases:-} distPhase ${postPhases:-}";
     #+END_EXAMPLE

     Be aware that there are also shell functions with the same name
     as phases, so if (for example) the configurePhase variable is
     defined, then the following do two different things:

     #+BEGIN_EXAMPLE
     [nix-shell] configurePhase
     [nix-shell] eval "$configurePhase"
     #+END_EXAMPLE

     Running individual phases:

     #+BEGIN_EXAMPLE
     [nix-shell] eval "${!prePhases:-}"  # use ! because it is a list of vars
     # If already in a checked-out copy of the source, skip the unpackPhase
     [nix-shell] eval "$patchPhase"
     [nix-shell] eval "${!preConfigurePhases:-}"
     [nix-shell] eval "$configurePhase"
     ...
     #+END_EXAMPLE

* FAQ

** Why ~config.nix~ and not ~default.nix~?

   There's no critical reason, but since the default.nix is
   customarily used for the description of a single package, a
   different name for the "project configuration" was chosen as the
   recommendation.

** Why not just use overlays?

   Overlays are fine for global needs.  They are less useful in cases
   like:

    * Working on several different projects that have the same
      dependencies but different versions of those dependencies.

    * Needing different dependency versions for different compilers.

    * Configuring Hydra.

  The devnix configuration and utilities are designed to be used on a
  per-project basis.
